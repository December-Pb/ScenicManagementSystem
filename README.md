系统设计
1.	Distribution类表示的是景点分布图，是最主要的类，其中的方法实现了创建、修改、输出、等功能。特别指出，规划图采用Kruskal最小生成树算法。
属性中最主要的是景点类的一个Array List，所有的操作都在此基础上进行。
2.	EdgeLinkedList类表示的是每个景点各自连结的边，即道路。道路的用邻接链表实现。在这个类中还定义了一个内部类Node，以表示其他景点，通过EdgeLinkedList的景点和Node中的景点可唯一确定一条边。
Node类中有景点的简单信息，包括名称和路长，以及下一节点的指针。为更好地设计程序，在EdgeLinkedList中设置了head，cursor，pre和tail属性，方便控制链表。
3.	Vex类表示单个景点。其中包括了一个景点所具备的所有信息，和一些列set、get方法。另外还包括了其他的控制信息，例如，在深度优先遍历时，用visited来表示该点是否访问过。景点类在Distribution类中以ArrayList的形式储存。
4.	ShortestPath类包含了所有查询最短路径的算法。通过迪杰斯特拉算法，找到最短路径和最短距离。
5.	Loop类涉及到的是图中回路的所有属性和方法。构造方法中接收创建好的景点分布图和生成完成的导游路线图，然后在各个方法中进行计算。
6.	Park 类和Car类分别表示停车场管理子系统和汽车。由于停车场与景区相比有一定的独立性，所以单独创建一个类。在Park类中用Car的ArrayList表示停车场内外的车辆。场内车辆的进入和离开用栈模拟。场外等待车辆用队列模拟。
7.	Menu实现了管理系统主菜单的各个功能。

程序设计
1.	边信息的删除：边信息用EdgeLinkedList中的Node类的链表存贮，实现了增删改查的功能。在删除边信息时，使用了pre这个属性，当cursor在遍历整个链表的时候，pre始终指向cursor的前一个节点。当cursor找到待删除节点时，将cursor的next属性代替pre的next属性，从而跳过cursor，达到删除的目的。
2.	生成导游路线图：采用深度遍历并使用迭代法。每次查找都需要先获得一个顶点（景点的名称），通过遍历vexList（景点的ArrayList）找到该点并标记为已访问。随后遍历该点对应的边的链表，并判断链表中的点是否访问过，若访问过则移动光标（cursor）；若没访问过，则以此点为新的定点进行迭代；若链表中的所有点均已访问过，则return到上一层。
每次查找都把得到的景点名称加在route字符串中，迭代完成后，打印route输出结果。
3.	最短路径：采用Dijkstra算法。首先确定起点，将起点自身的最短距离设为零，其他点初始化为无穷大。从起点出发，遍历所有的点，对遍历到的当前的点，查看它所直接连接的相邻的点，判断若从当前点出发到相邻点的话，最短距离是否能更短，若能则更新，并在相邻点中记录当前点，作为最短路径的前一个点；若不能则跳过。重复以上工作，直到遍历完全，则生成了所有点到出发点的最小距离和最短路径。
4.	排序：采用快速排序法和迭代法根据受欢迎度对景点进行排序。调用方法的时候传入i，j两个参数，表示要排序的范围。每轮排序选取一个点进行分治，首次选取定点，之后每轮的分治点由上一轮决定。
5.	最小生成树：采用Kruskal算法，在此方法中加入一个内部类，用于存储路的信息。把所有的路按照距离长短，由短到长排列，并选取尽可能短的路径，若两点之间的其他的路已经选取，则放弃该路。
6.	拓扑排序：先设置每个点的入度，然后找到入度为零的点，并删除该点所连接的所有边。若在某次循环中发现没有入度为零的点，则表示存在环。
7.	栈和队列：停车场用栈来表示，先进后出，便道等待用队列，先进先出。
8.	折半查找：对景点的受欢迎度做查找。首先对所有的点进行排序。声明整型low表示折半查找的左端，整型high表示右端，整型mid表示中间点。每次循环将中间点与待查找的对象进行对比，若查找对象大，则将mid+1赋值给给low；若查找对象小，则将mid-1赋值给high。
